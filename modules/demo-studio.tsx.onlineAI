// modules/demo-studio.tsx
import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';
import { SceneModule } from '../core/types';
import { generateThreeJSScript } from '../core/genai';

// ============================================================================
// ASSET GENERATORS (The "Crafted" Elements)
// ============================================================================

const createTree = (x: number, y: number, z: number) => {
    const group = new THREE.Group();
    
    // Trunk
    const trunkGeom = new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.9 });
    const trunk = new THREE.Mesh(trunkGeom, trunkMat);
    trunk.position.y = 0.75;
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    group.add(trunk);

    // Leaves (Low Poly Style)
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27, roughness: 0.8, flatShading: true });
    
    const t1 = new THREE.Mesh(new THREE.ConeGeometry(1.5, 1.5, 6), leafMat);
    t1.position.y = 2.0;
    t1.castShadow = true;
    t1.receiveShadow = true;
    
    const t2 = new THREE.Mesh(new THREE.ConeGeometry(1.1, 1.5, 6), leafMat);
    t2.position.y = 2.8;
    t2.castShadow = true;
    t2.receiveShadow = true;

    group.add(t1, t2);
    group.position.set(x, y, z);
    
    // Randomize
    const s = 0.8 + Math.random() * 0.5;
    group.scale.set(s, s, s);
    group.rotation.y = Math.random() * Math.PI;
    
    return group;
};

const createCloud = (x: number, y: number, z: number) => {
    const group = new THREE.Group();
    const cloudMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffff, 
        roughness: 0.1, 
        flatShading: true,
        transparent: true,
        opacity: 0.8
    });

    const chunks = 3 + Math.floor(Math.random() * 3);
    for(let i=0; i<chunks; i++) {
        const mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(2 + Math.random(), 0), cloudMat);
        mesh.position.set(
            (Math.random() - 0.5) * 3,
            (Math.random() - 0.5) * 1,
            (Math.random() - 0.5) * 2
        );
        group.add(mesh);
    }
    
    group.position.set(x, y, z);
    return group;
};

// ============================================================================
// TERRAIN SYSTEM
// ============================================================================

interface TerrainProvider {
  getHeight(x: number, z: number): number;
  mesh: THREE.Mesh;
}

const createProceduralTerrain = (scene: THREE.Scene): TerrainProvider => {
  const size = 120;
  
  const getHeight = (x: number, z: number) => {
    return (Math.sin(x / 10) + Math.cos(z / 10)) * 3.0 + (Math.sin(x/3)*0.5);
  };

  const geometry = new THREE.PlaneGeometry(size, size, 64, 64);
  geometry.rotateX(-Math.PI / 2);
  
  const positions = geometry.attributes.position;
  for (let i = 0; i < positions.count; i++) {
    positions.setY(i, getHeight(positions.getX(i), positions.getZ(i)));
  }
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({ 
    color: 0x4a7c38, // Richer green
    roughness: 0.9, 
    flatShading: true 
  });
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.receiveShadow = true;
  scene.add(mesh);

  return { getHeight, mesh };
};

// ============================================================================
// MODULE DEFINITION
// ============================================================================

export const DemoStudioModule: SceneModule = {
  id: 'DEMO_STUDIO_V1',
  name: 'VirtuaStudio GenAI Demo',
  description: 'AI Prop Generation & Cinematic Controls',
  type: 'PLAYGROUND',
  tags: ['demo', 'genai', 'character'],
  deliverables: [],

  init: (scene, camera) => {
    // --- Environment ---
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.FogExp2(0x87ceeb, 0.012);
    camera.position.set(0, 5, -10);

    // --- Lighting ---
    const ambient = new THREE.AmbientLight(0x404040, 0.6);
    scene.add(ambient);

    const sun = new THREE.DirectionalLight(0xfffaed, 1.8);
    sun.castShadow = true;
    sun.shadow.mapSize.set(2048, 2048);
    sun.shadow.bias = -0.0005;
    sun.position.set(50, 100, 50);
    scene.add(sun);

    // --- Systems ---
    const terrain = createProceduralTerrain(scene);

    // --- Crafted Assets (Trees & Clouds) ---
    // Populate the world so it's not empty
    const envGroup = new THREE.Group();
    
    // Trees
    for(let i=0; i<50; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 10 + Math.random() * 45; // Avoid center clearing
        const x = Math.sin(angle) * dist;
        const z = Math.cos(angle) * dist;
        const y = terrain.getHeight(x, z);
        envGroup.add(createTree(x, y, z));
    }

    // Clouds
    const clouds: THREE.Group[] = [];
    for(let i=0; i<8; i++) {
        const c = createCloud(
            (Math.random() - 0.5) * 100,
            15 + Math.random() * 10,
            (Math.random() - 0.5) * 100
        );
        clouds.push(c);
        scene.add(c);
    }
    
    scene.add(envGroup);

    // --- Character ---
    const character = new THREE.Group();
    const charMat = new THREE.MeshStandardMaterial({ color: 0xff6347, roughness: 0.4 });
    
    const createBox = (w:number, h:number, d:number, y:number) => {
       const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), charMat);
       m.position.y = y;
       m.castShadow = true;
       return m;
    };
    
    const head = createBox(0.4, 0.4, 0.4, 1.6);
    const body = createBox(0.5, 0.7, 0.3, 0.95);
    character.add(head, body);
    scene.add(character);

    return {
      scene,
      camera,
      sun,
      terrain,
      character,
      clouds,
      envGroup,
      objects: [] as THREE.Object3D[],
      params: {
        isPlaying: true,
        camMode: 'TRACKING' as 'TRACKING' | 'DRONE',
        timeOfDay: 50,
        prompt: 'A stone monolith with glowing runes', // Updated default prompt
        isGenerating: false,
        error: null as string | null
      },
      animState: { angle: 0 }
    };
  },

  update: (ctx, time, delta) => {
    const { params, animState, character, terrain, sun, scene, camera, clouds } = ctx;

    if (params.isPlaying) {
      animState.angle += 0.01;
      
      // Character Walk
      const radius = 12;
      const x = Math.sin(animState.angle) * radius;
      const z = Math.cos(animState.angle) * radius;
      const y = terrain.getHeight(x, z);
      
      character.position.set(x, y, z);
      character.lookAt(
        Math.sin(animState.angle + 0.1) * radius,
        y,
        Math.cos(animState.angle + 0.1) * radius
      );

      // Cloud drift
      clouds.forEach((c: THREE.Group, i: number) => {
          c.position.x += delta * (1 + i * 0.2);
          if (c.position.x > 60) c.position.x = -60;
      });
    }

    // Time of Day
    const t = params.timeOfDay / 100;
    const sunX = Math.sin((t - 0.5) * Math.PI) * 100;
    const sunY = Math.cos((t - 0.5) * Math.PI) * 100;
    sun.position.set(sunX, sunY, 25);
    
    // Sky Color Lerp
    const isDay = t > 0.2 && t < 0.8;
    const color = isDay ? 0x87ceeb : 0x0a1a2a;
    if (scene.background instanceof THREE.Color) scene.background.setHex(color);
    if (scene.fog) scene.fog.color.setHex(color);

    // Camera
    if (params.camMode === 'TRACKING') {
      const offset = new THREE.Vector3(0, 6, -12).applyQuaternion(character.quaternion);
      camera.position.lerp(character.position.clone().add(offset), 0.05);
      camera.lookAt(character.position.clone().add(new THREE.Vector3(0, 1.5, 0)));
    }
  },

  dispose: (ctx) => {
    ctx.scene.clear();
  },

  UI: ({ ctx, onUpdate, engineAPI }) => {
    const generateProp = async () => {
        if (!ctx.params.prompt) return;
        
        ctx.params.isGenerating = true;
        ctx.params.error = null;
        onUpdate({...ctx});

        try {
            const code = await generateThreeJSScript(ctx.params.prompt);
            
            // Safe(r) execution of generated code
            const createFunc = new Function('THREE', code);
            const group = createFunc(THREE) as THREE.Group;
            
            if (group) {
                // Find a spot near the character but not on top of them
                const angle = ctx.animState.angle + (Math.random() * 0.5 + 0.5); // Ahead of character
                const r = 12 + (Math.random() * 4 - 2); 
                const x = Math.sin(angle) * r;
                const z = Math.cos(angle) * r;
                const y = ctx.terrain.getHeight(x, z);
                
                group.position.set(x, y, z);
                // Random Y Rotation
                group.rotation.y = Math.random() * Math.PI * 2;

                group.traverse((c) => { 
                    if (c instanceof THREE.Mesh) {
                        c.castShadow = true; 
                        c.receiveShadow = true;
                    }
                });
                
                ctx.scene.add(group);
                ctx.objects.push(group);
            }
        } catch (e: any) {
            console.error(e);
            ctx.params.error = "Failed to generate: " + e.message;
        } finally {
            ctx.params.isGenerating = false;
            onUpdate({...ctx});
        }
    };

    const clearProps = () => {
        ctx.objects.forEach((o: THREE.Object3D) => ctx.scene.remove(o));
        ctx.objects = [];
        onUpdate({...ctx});
    };

    return (
      <div className="module-ui">
        <div className="panel-header">GENAI STUDIO</div>
        
        <div className="control-row">
            <label>GENERATE PROP</label>
            <div style={{display: 'flex', flexDirection: 'column', gap: '5px'}}>
                <textarea 
                    rows={2}
                    style={{
                        background: '#222', 
                        border: '1px solid #444', 
                        color: 'white', 
                        padding: '5px',
                        fontSize: '11px',
                        resize: 'none',
                        fontFamily: 'monospace'
                    }}
                    value={ctx.params.prompt}
                    onChange={(e) => { ctx.params.prompt = e.target.value; onUpdate({...ctx}); }}
                    placeholder="Describe a 3D object..."
                />
                <button 
                    className="action-btn"
                    disabled={ctx.params.isGenerating}
                    onClick={generateProp}
                >
                    {ctx.params.isGenerating ? 'GENERATING CODE...' : 'GENERATE ASSET'}
                </button>
                {ctx.params.error && (
                    <div style={{color: '#ff4444', fontSize: '10px'}}>{ctx.params.error}</div>
                )}
            </div>
        </div>

        <div className="control-row">
            <div className="btn-group">
                 <button onClick={clearProps}>CLEAR AI ASSETS ({ctx.objects.length})</button>
            </div>
        </div>

        <div className="panel-header" style={{marginTop: '20px'}}>SCENE CONTROLS</div>
        
        <div className="control-row">
          <label>CAMERA</label>
          <div className="btn-group">
            <button 
              className={ctx.params.camMode === 'TRACKING' ? 'active' : ''} 
              onClick={() => { ctx.params.camMode = 'TRACKING'; engineAPI.setCameraMode('scripted'); onUpdate({...ctx}); }}
            >TRACKING</button>
            <button 
              className={ctx.params.camMode === 'DRONE' ? 'active' : ''} 
              onClick={() => { ctx.params.camMode = 'DRONE'; engineAPI.setCameraMode('orbit'); onUpdate({...ctx}); }}
            >DRONE</button>
          </div>
        </div>

        <div className="control-row">
          <label>TIME: {ctx.params.timeOfDay}%</label>
          <input 
            type="range" 
            min="0" 
            max="100" 
            value={ctx.params.timeOfDay} 
            onChange={(e) => { ctx.params.timeOfDay = parseInt(e.target.value); onUpdate({...ctx}); }} 
          />
        </div>
      </div>
    );
  }
};

export default DemoStudioModule;